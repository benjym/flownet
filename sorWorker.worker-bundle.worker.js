/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./js/sorWorker.worker.js":
/*!********************************!*\
  !*** ./js/sorWorker.worker.js ***!
  \********************************/
/***/ (() => {

eval("// Keep track of the latest task ID across messages\nlet currentTaskId = 0;\n\nself.onmessage = function (event) {\n    const { taskId, points, gridSize, tolerance, omega, maxIterations, drain } = event.data;\n\n    // Update to the latest task ID\n    currentTaskId = taskId;\n\n    const cols = gridSize;\n    const rows = gridSize;\n\n    // Grid spacing for numerical derivatives\n    const dx = 1 / (cols - 1);\n    const dy = 1 / (rows - 1);\n\n    let potential = Array.from({ length: rows }, () => Array(cols).fill(0));\n    let streamfunction = Array.from({ length: rows }, () => Array(cols).fill(0));\n    let isFL = Array.from({ length: rows }, () => Array(cols).fill(false));\n    let isEP = Array.from({ length: rows }, () => Array(cols).fill(false));\n\n    function isPointInPolygon(y, x, points) {\n        let inside = false;\n        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {\n            const xi = points[i].x * (gridSize);\n            const yi = points[i].y * (gridSize);\n            const xj = points[j].x * (gridSize);\n            const yj = points[j].y * (gridSize);\n\n            const intersect = ((yi > y) !== (yj > y)) &&\n                (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n            if (intersect) {\n                inside = !inside;\n            }\n        }\n        return inside;\n    }\n\n    // Find min and max potential values from EP boundaries for better initialization\n    let minPotential = Infinity;\n    let maxPotential = -Infinity;\n    points.forEach(point => {\n        if (point.BC.type === \"EP\" && point.BC.value !== undefined) {\n            minPotential = Math.min(minPotential, point.BC.value);\n            maxPotential = Math.max(maxPotential, point.BC.value);\n        }\n    });\n\n    // Include drain potential in min/max calculation\n    if (drain && drain.BC && drain.BC.value !== undefined) {\n        minPotential = Math.min(minPotential, drain.BC.value);\n        maxPotential = Math.max(maxPotential, drain.BC.value);\n    }\n\n    // If no EP boundaries found, use default range\n    if (minPotential === Infinity) {\n        minPotential = 0;\n        maxPotential = 1;\n    }\n\n    // Initialize with average of boundary values for better convergence\n    const avgPotential = (minPotential + maxPotential) / 2;\n\n    // Store potential range for relative convergence checking\n    const potentialRange = Math.max(maxPotential - minPotential, 1e-12); // Prevent division by zero\n\n    console.log(`Potential range: ${potentialRange}, Using relative tolerance: ${tolerance}`);\n\n    // Initialize the domain: mark all points\n    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n            if (!isPointInPolygon(row, col, points)) {\n                potential[row][col] = null; // Mark as outside the polygon\n            } else {\n                potential[row][col] = avgPotential; // Initialize with average of boundary values\n            }\n        }\n    }\n    // Handle boundary conditions\n    points.forEach((point, i) => {\n        const nextPoint = points[(i + 1) % points.length]; // Wrap back to the first point\n        const deltaX = nextPoint.x - point.x;\n        const deltaY = nextPoint.y - point.y;\n        const steps = Math.max(Math.abs(deltaX), Math.abs(deltaY)) * (gridSize - 1);\n\n        const xIncrement = deltaX / steps;\n        const yIncrement = deltaY / steps;\n\n        let x = point.x;\n        let y = point.y;\n\n        // Apply boundary conditions along each boundary segment\n        for (let step = 0; step <= steps; step++) {\n            const col = Math.round(x * (gridSize - 1));\n            const row = Math.round(y * (gridSize - 1));\n\n            if (row >= 0 && row < rows && col >= 0 && col < cols) {\n                if (point.BC.type === \"EP\") {\n                    potential[row][col] = point.BC.value;\n                    isEP[row][col] = true;\n                } else if (point.BC.type === \"FL\") {\n                    isFL[row][col] = true;\n                }\n            }\n\n            x += xIncrement;\n            y += yIncrement;\n        }\n    });\n\n    // Handle drain boundary condition (circular EP)\n    if (drain) {\n        const centerCol = Math.round(drain.x * (gridSize - 1));\n        const centerRow = Math.round(drain.y * (gridSize - 1));\n        const radiusInGridUnits = drain.r * (gridSize - 1);\n\n        for (let row = 0; row < rows; row++) {\n            for (let col = 0; col < cols; col++) {\n                const distance = Math.sqrt(\n                    Math.pow(col - centerCol, 2) + Math.pow(row - centerRow, 2)\n                );\n\n                if (distance <= radiusInGridUnits) {\n                    potential[row][col] = drain.BC.value;\n                    isEP[row][col] = true;\n                }\n            }\n        }\n    }\n\n    function applyNeumannBC() {\n        for (let row = 0; row < rows; row++) {\n            for (let col = 0; col < cols; col++) {\n                if (isFL[row][col] && !isEP[row][col]) {\n\n                    const neighbors = [\n                        { r: row - 1, c: col, dir: 'north' },\n                        { r: row + 1, c: col, dir: 'south' },\n                        { r: row, c: col - 1, dir: 'west' },\n                        { r: row, c: col + 1, dir: 'east' }\n                    ];\n\n                    let interiorNeighbors = [];\n\n                    neighbors.forEach(({ r, c, dir }) => {\n                        if (r >= 0 && r < rows && c >= 0 && c < cols &&\n                            potential[r][c] !== null && !isEP[r][c] && !isFL[r][c]) {\n                            interiorNeighbors.push({ r, c, dir, value: potential[r][c] });\n                        }\n                    });\n\n                    // Apply zero normal gradient - extrapolate from interior point(s)\n                    if (interiorNeighbors.length > 0) {\n                        let newValue = potential[row][col]; // Default to current value\n\n                        if (interiorNeighbors.length === 1) {\n                            // Single interior neighbor - simple extrapolation for zero gradient\n                            // Set boundary value equal to interior neighbor (zero gradient)\n                            newValue = interiorNeighbors[0].value;\n                        } else {\n                            // Multiple interior neighbors - use directional extrapolation\n                            // For each pair of opposite directions, enforce zero gradient\n                            const north = interiorNeighbors.find(n => n.dir === 'north');\n                            const south = interiorNeighbors.find(n => n.dir === 'south');\n                            const west = interiorNeighbors.find(n => n.dir === 'west');\n                            const east = interiorNeighbors.find(n => n.dir === 'east');\n\n                            let gradSum = 0;\n                            let gradCount = 0;\n\n                            // For vertical gradient (north-south)\n                            if (north && south) {\n                                // Interior on both sides - maintain current value (already satisfies zero gradient)\n                                gradSum += potential[row][col];\n                                gradCount++;\n                            } else if (north) {\n                                // Extrapolate from north: φ_boundary = φ_north (zero gradient in vertical direction)\n                                gradSum += north.value;\n                                gradCount++;\n                            } else if (south) {\n                                // Extrapolate from south: φ_boundary = φ_south (zero gradient in vertical direction)\n                                gradSum += south.value;\n                                gradCount++;\n                            }\n\n                            // For horizontal gradient (west-east)\n                            if (west && east) {\n                                // Interior on both sides - maintain current value (already satisfies zero gradient)\n                                gradSum += potential[row][col];\n                                gradCount++;\n                            } else if (west) {\n                                // Extrapolate from west: φ_boundary = φ_west (zero gradient in horizontal direction)\n                                gradSum += west.value;\n                                gradCount++;\n                            } else if (east) {\n                                // Extrapolate from east: φ_boundary = φ_east (zero gradient in horizontal direction)\n                                gradSum += east.value;\n                                gradCount++;\n                            }\n\n                            if (gradCount > 0) {\n                                newValue = gradSum / gradCount;\n                            } else {\n                                // Fallback: average all interior neighbors\n                                newValue = interiorNeighbors.reduce((sum, n) => sum + n.value, 0) / interiorNeighbors.length;\n                            }\n                        }\n\n                        // Apply with relaxation for stability\n                        potential[row][col] = (1 - omega) * potential[row][col] + omega * newValue;\n                    }\n                    // If no interior neighbors found, keep current value (shouldn't happen in well-posed problems)\n                }\n            }\n        }\n    }\n\n    // Successive Over-Relaxation (SOR) for potential\n    let converged = false;\n    let iterations = 0;\n\n    while (!converged && iterations < maxIterations) {\n        if (taskId < currentTaskId) return;\n\n        converged = true;\n        let maxChange = 0;\n\n        for (let row = 1; row < rows - 1; row++) {\n            for (let col = 1; col < cols - 1; col++) {\n                if (potential[row][col] === null || isEP[row][col] || isFL[row][col]) continue; // Skip boundaries and outside domain\n\n                const oldPotential = potential[row][col];\n\n                // Standard Laplace equation for interior points only\n                potential[row][col] = (1 - omega) * oldPotential + omega * (\n                    (potential[row - 1][col] + potential[row + 1][col] +\n                        potential[row][col - 1] + potential[row][col + 1]) / 4\n                );\n\n                const change = Math.abs(potential[row][col] - oldPotential);\n                maxChange = Math.max(maxChange, change);\n\n                // Normalize change by potential range for relative convergence\n                const relativeChange = change / potentialRange;\n                if (relativeChange > tolerance) {\n                    converged = false;\n                }\n            }\n        }\n\n        // Apply Neumann boundary conditions after each iteration\n        applyNeumannBC();\n\n        iterations++;\n    }\n\n    // console.log(`SOR converged after ${iterations} iterations`);\n\n    if (iterations >= maxIterations) {\n        console.warn(\"SOR did not converge within maximum iterations\");\n    }\n\n    // Calculate streamfunction from potential field\n    // Use simple, robust integration method for orthogonal flow nets\n    // Relationship: ∂ψ/∂x = ∂φ/∂y and ∂ψ/∂y = -∂φ/∂x\n\n    // Initialize streamfunction \n    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n            if (potential[row][col] === null) {\n                streamfunction[row][col] = null;\n            } else {\n                streamfunction[row][col] = 0.0;\n            }\n        }\n    }\n\n    // Set a reference point (bottom-left corner of domain)\n    let refRow = -1, refCol = -1;\n    for (let row = rows - 1; row >= 0; row--) {\n        for (let col = 0; col < cols; col++) {\n            if (potential[row][col] !== null) {\n                refRow = row;\n                refCol = col;\n                break;\n            }\n        }\n        if (refRow !== -1) break;\n    }\n\n    if (refRow !== -1) {\n        streamfunction[refRow][refCol] = 0.0;\n\n        // First, integrate along the bottom row (constant y)\n        for (let col = refCol + 1; col < cols; col++) {\n            if (potential[refRow][col] !== null && potential[refRow][col - 1] !== null) {\n                // ∂ψ/∂x = ∂φ/∂y (using central difference for ∂φ/∂y)\n                let dPhi_dy = 0;\n                if (refRow > 0 && refRow < rows - 1 &&\n                    potential[refRow + 1][col] !== null && potential[refRow - 1][col] !== null) {\n                    dPhi_dy = (potential[refRow + 1][col] - potential[refRow - 1][col]) / (2 * dy);\n                } else if (refRow > 0 && potential[refRow - 1][col] !== null) {\n                    dPhi_dy = (potential[refRow][col] - potential[refRow - 1][col]) / dy;\n                } else if (refRow < rows - 1 && potential[refRow + 1][col] !== null) {\n                    dPhi_dy = (potential[refRow + 1][col] - potential[refRow][col]) / dy;\n                }\n\n                streamfunction[refRow][col] = streamfunction[refRow][col - 1] + dPhi_dy * dx;\n            } else {\n                streamfunction[refRow][col] = null;\n            }\n        }\n\n        // Then integrate upward from each point on the bottom row\n        for (let col = refCol; col < cols; col++) {\n            if (potential[refRow][col] !== null) {\n                for (let row = refRow - 1; row >= 0; row--) {\n                    if (potential[row][col] !== null && potential[row + 1][col] !== null) {\n                        // ∂ψ/∂y = -∂φ/∂x (using central difference for ∂φ/∂x)\n                        let dPhi_dx = 0;\n                        if (col > 0 && col < cols - 1 &&\n                            potential[row][col + 1] !== null && potential[row][col - 1] !== null) {\n                            dPhi_dx = (potential[row][col + 1] - potential[row][col - 1]) / (2 * dx);\n                        } else if (col > 0 && potential[row][col - 1] !== null) {\n                            dPhi_dx = (potential[row][col] - potential[row][col - 1]) / dx;\n                        } else if (col < cols - 1 && potential[row][col + 1] !== null) {\n                            dPhi_dx = (potential[row][col + 1] - potential[row][col]) / dx;\n                        }\n\n                        streamfunction[row][col] = streamfunction[row + 1][col] - dPhi_dx * dy;\n                    } else {\n                        streamfunction[row][col] = null;\n                    }\n                }\n            }\n        }\n\n        // Similarly integrate downward from the reference row\n        for (let col = refCol; col < cols; col++) {\n            if (potential[refRow][col] !== null) {\n                for (let row = refRow + 1; row < rows; row++) {\n                    if (potential[row][col] !== null && potential[row - 1][col] !== null) {\n                        // ∂ψ/∂y = -∂φ/∂x\n                        let dPhi_dx = 0;\n                        if (col > 0 && col < cols - 1 &&\n                            potential[row][col + 1] !== null && potential[row][col - 1] !== null) {\n                            dPhi_dx = (potential[row][col + 1] - potential[row][col - 1]) / (2 * dx);\n                        } else if (col > 0 && potential[row][col - 1] !== null) {\n                            dPhi_dx = (potential[row][col] - potential[row][col - 1]) / dx;\n                        } else if (col < cols - 1 && potential[row][col + 1] !== null) {\n                            dPhi_dx = (potential[row][col + 1] - potential[row][col]) / dx;\n                        }\n\n                        streamfunction[row][col] = streamfunction[row - 1][col] - dPhi_dx * dy;\n                    } else {\n                        streamfunction[row][col] = null;\n                    }\n                }\n            }\n        }\n    }\n\n    self.postMessage({\n        taskId: taskId,\n        potential: potential,\n        streamfunction: streamfunction,\n    });\n};\n\n\n//# sourceURL=webpack://flownet/./js/sorWorker.worker.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./js/sorWorker.worker.js"]();
/******/ 	
/******/ })()
;