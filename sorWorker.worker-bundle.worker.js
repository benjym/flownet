/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./js/sorWorker.worker.js":
/*!********************************!*\
  !*** ./js/sorWorker.worker.js ***!
  \********************************/
/***/ (() => {

eval("self.onmessage = function (event) {\n    const { taskId, points, gridSize, tolerance, omega } = event.data;\n\n    let currentTaskId = 0;\n    currentTaskId++;\n\n    if (taskId < currentTaskId) return;\n\n    const cols = gridSize;\n    const rows = gridSize;\n    let potential = Array.from({ length: rows }, () => Array(cols).fill(0));\n    let streamfunction = Array.from({ length: rows }, () => Array(cols).fill(0));\n    let isFL = Array.from({ length: rows }, () => Array(cols).fill(false));\n    let isEP = Array.from({ length: rows }, () => Array(cols).fill(false));\n\n    // Helper function to find the first numerical BC going backwards or forwards\n    function findNearestBC(points, type, startIndex, direction) {\n        let index = startIndex;\n        if (index < 0) index = points.length - 1;\n        if (index > points.length - 1) index = 0;\n\n        for (let i = 0; i < points.length-1; i++) {\n            const point = points[index];\n            if (point.BC.type === type) {\n                return { index, BC: point.BC.value };\n            }\n            index += direction;\n            if (index < 0) index = points.length - 1;\n            if (index > points.length - 1) index = 0;\n        \n        }\n        console.error(\"Did not find a Nearest BC for type: \", type, \"startIndex: \", startIndex, \"direction: \", direction);\n        // return null; // No numerical BC found in this direction\n    }\n\n    // function isPointInPolygon(x, y, points) {\n    //     let inside = false;\n    //     for (let i = 0, j = points.length - 1; i < points.length; j = i++) {\n    //         const xi = points[i].x * (gridSize - 1);\n    //         const yi = points[i].y * (gridSize - 1);\n    //         const xj = points[j].x * (gridSize - 1);\n    //         const yj = points[j].y * (gridSize - 1);\n    \n    //         const intersect = ((yi > y) !== (yj > y)) &&\n    //             (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n    //         if (intersect) {\n    //             inside = !inside;\n    //         }\n    //     }\n    //     return inside;\n    // }\n    \n\n    // Initialize the domain: mark all points\n    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n            // if (!isPointInPolygon(row, col, points)) {\n                // potential[row][col] = null; // Mark as outside the polygon\n                // console.log('OUTSIDE')\n            // } else {\n                // console.log('INSIDE')\n                potential[row][col] = 0; // Default initialization inside the polygon\n            // }\n        }\n    }\n\n    // Handle boundary conditions\n    points.forEach((point, i) => {\n        const nextPoint = points[(i + 1) % points.length]; // Wrap back to the first point\n        const dx = nextPoint.x - point.x;\n        const dy = nextPoint.y - point.y;\n        const steps = Math.max(Math.abs(dx), Math.abs(dy)) * (gridSize - 1);\n    \n        const xIncrement = dx / steps;\n        const yIncrement = dy / steps;\n    \n        let x = point.x;\n        let y = point.y;\n    \n        // Handle EP (Equipotential) boundaries\n        if (point.BC.type === \"EP\") {\n            const nearestBackward = findNearestBC(points, \"FL\", i-1, -1); // BC before the boundary\n            const nearestForward = findNearestBC(points, \"FL\", i + 1, 1); // BC after the boundary\n            const startBC = nearestBackward.BC;\n            const endBC = nearestForward.BC;\n            // console.log(nearestBackward, nearestForward)//, startBC, endBC)\n            for (let step = 0; step <= steps; step++) {\n                const col = Math.round(x * (gridSize - 1));\n                const row = Math.round(y * (gridSize - 1));\n    \n                potential[row][col] = point.BC.value; // Fixed EP value\n                isEP[row][col] = true;\n\n                const t = step / steps; // Linear interpolation factor\n                streamfunction[row][col] = (1 - t) * startBC + t * endBC;\n    \n                x += xIncrement;\n                y += yIncrement;\n            }\n        }\n    \n        // Handle FL (Flowline) boundaries\n        if (point.BC.type === \"FL\" ){\n            // Find the nearest numerical BCs for interpolation\n            const nearestBackward = findNearestBC(points, \"EP\", i-1, -1); // BC before the FL boundary\n            const nearestForward = findNearestBC(points, \"EP\", i + 1, 1); // BC after the FL boundary\n            const startBC = nearestBackward.BC;\n            const endBC = nearestForward.BC;\n    \n            if (startBC !== null && endBC !== null) {\n                for (let step = 0; step <= steps; step++) {\n                    const col = Math.round(x * (gridSize - 1));\n                    const row = Math.round(y * (gridSize - 1));\n    \n                    const t = step / steps; // Linear interpolation factor\n                    potential[row][col] = (1 - t) * startBC + t * endBC;\n                    isFL[row][col] = true;\n\n                    streamfunction[row][col] = point.BC.value;\n    \n                    x += xIncrement;\n                    y += yIncrement;\n                }\n            }\n        }\n    });\n    \n    \n    \n\n    // Successive Over-Relaxation (SOR) for potential\n    let converged = false;\n    while (!converged) {\n        if (taskId < currentTaskId) return;\n\n        converged = true;\n        for (let row = 1; row < rows - 1; row++) {\n            for (let col = 1; col < cols - 1; col++) {\n                if (potential[row][col] === null || isEP[row][col]) continue; // Skip EP boundaries\n\n                if (isFL[row][col]) {\n                    // Propagate tangentially along flowline\n                    potential[row][col] = (\n                        potential[row][col - 1] +\n                        potential[row][col + 1]\n                    ) / 2; // Zero-gradient normal to flowline\n                } else {\n                    const oldPotential = potential[row][col];\n                    const newPotential = (1 - omega) * oldPotential + omega * (\n                        (potential[row - 1][col] + potential[row + 1][col] +\n                            potential[row][col - 1] + potential[row][col + 1]) / 4\n                    );\n\n                    if (Math.abs(newPotential - oldPotential) > tolerance) {\n                        converged = false;\n                    }\n                    potential[row][col] = newPotential;\n                }\n            }\n        }\n    }\n\n    // Calculate streamfunction iteratively\n    const dx = 1 / (cols - 1);\n    for (let row = 1; row < rows - 1; row++) {\n        for (let col = 1; col < cols - 1; col++) {\n            if (streamfunction[row][col] === null) continue;\n\n            const dPhi_dx = (potential[row][col + 1] - potential[row][col - 1]) / 2/dx;\n            // const dPhi_dy = (potential[row + 1][col] - potential[row - 1][col]) / 2;\n\n            streamfunction[row][col] = streamfunction[row - 1][col] + dPhi_dx;\n        }\n    }\n\n    // Send results back\n    if (taskId === currentTaskId) {\n        self.postMessage({ potential, streamfunction });\n    }\n};\n\n\n\n\n//# sourceURL=webpack://constitutive-models/./js/sorWorker.worker.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./js/sorWorker.worker.js"]();
/******/ 	
/******/ })()
;